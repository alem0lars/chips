#!/usr/bin/env ruby


# {{{ = IGNORE THIS ============================================================

module Utils # {{{

  def info(prefix, msg = nil) # {{{
    if msg.nil?
      puts("#{prefix}")
    else
      puts("#{prefix} #{msg}")
    end
  end # }}}

  def warning(msg, ask_continue: true) # {{{
    puts("⚠ #{msg}")
    exit(-1) if ask_continue && !quiz('continue')
  end # }}}

  def error(msg) # {{{
    puts("☠ #{msg}")
    exit(-1)
  end # }}}

  def ask(question, type: :string) # {{{
    $stdout.write("#{question.strip}? ")
    answer = $stdin.gets.chomp 
    case type
    when :bool
      if answer =~ /y|ye|yes|yeah|ofc/i
        true
      elsif answer =~ /n|no|fuck|fuck\s+you|fuck\s+off/i
        false
      else
        info "Answer misunderstood."
        ask(question, type: type)
      end
    when :string
      if answer.empty?
        warning "Empty answer.", ask_continue: false
        ask(question, type: type)
      else
        answer
      end
    when :int   then Integer(answer)
    when :float then Float(answer)
    when :array then answer.split(/\s*,\s*/)
    else
      error("Unhandled question type: `#{type}`.")
    end
  end # }}}
  
  def type_from_value(value) # {{{
    if value.is_a?(TrueClass) || value.is_a?(FalseClass) then :bool
    elsif value.is_a?(String) then :string
    elsif value.is_a?(Integer) then :int
    elsif value.is_a?(Float) then :float
    elsif value.is_a?(Array) then :array
    else error("Don't know how to handle `#{value.class}`.")
    end
  end # }}}
  
end # }}}

class CommandsExecutor # {{{
  
  include Utils
  
  def initialize
    @commands = []
  end

  # {{{ DSL.
  
  def syssetup(name: nil, value: nil, question: nil, msg: nil)
    error("Missing `name`.") if name.nil?
    error("Missing `name` or `question`.") if value.nil? && question.nil?
    
    name = [name] unless name.respond_to?(:each)
    value = ask(question) if question

    name.each { |n| systemsetup(n, value, msg) }
  end
  
  def sysconfig(msg: nil, name: nil, value: nil, question: nil)
    error("Missing `name`.") if name.nil?
    error("Missing `name` or `question`.") if value.nil? && question.nil?
    
    name = [name] unless name.respond_to?(:each)
    value = ask(question) if question

    name.each { |n| scutil_write(n, value, msg) }
  end
  
  def default(msg: nil, domain: :global, name: nil, value: nil, question: nil, type: nil)
    error("Missing `name`.") if name.nil?
    error("Missing `domain`.") if domain.nil?
    error("Missing `name` or `question`.") if value.nil? && question.nil?

    if question
      value = type.nil? ? ask(question) : ask(question, type: type) 
    end
    type = type_from_value(value) if type.nil?
    name = [name] unless name.respond_to?(:each)
    domain = "NSGlobalDomain" if domain == :global
    if domain =~ /^sysconfig:(.+)$/
      domain = "/Library/Preferences/SystemConfiguration/#{$1}"
    end

    name.each { |n| defaults_write(type, n, value, domain, msg) }
  end
  
  # }}}
  
  def execute_commands(dryrun)
    if dryrun
      info("Commands are:")
    else
      info("Executing commands..")
    end
    @commands.each do |command_info|
      info(command_info[:msg]) if command_info[:msg]
      if dryrun
        info("->", command_info[:cmd])
      else
        system(command_info[:cmd])
      end
    end
  end

  private
  
  def systemsetup(name, value, msg)
    @commands << {
      msg: msg,
      cmd: "sudo systemsetup -#{name} \"#{value}\""
    }
  end
  
  def scutil_write(name, value, msg)
    @commands << {
      msg: msg,
      cmd: "sudo scutil --set \"#{name}\" \"#{value}\""
    }
  end
  
  def defaults_write(type, name, value, domain, msg)
    type = type.to_s.to_sym
    error("Unknown type `#{type}`.") unless %i(string bool int float array).include?(type)
    
    value = type == :array ? value.map{ |v| "\"#{v}\"" }.join(" ") : "\"#{value}\""
      
    @commands << {
      msg: msg,
      cmd: "defaults write \"#{domain}\" \"#{name}\" -#{type} #{value}"
    }
  end

end # }}}

class Main # {{{
  
  include Utils
  
  def initialize
    @commands_executor = CommandsExecutor.new
  end

  def run(dryrun)
    yield(@commands_executor)
    @commands_executor.execute_commands(dryrun)
  end

  def self.run(dryrun: false, &block)
    new.run(dryrun, &block)
  end
  
end # }}}

# }}} ==========================================================================

# {{{ Some useful constants.

NSNavPanelExpandedStateForSaveMode = %w(
  NSNavPanelExpandedStateForSaveMode
  NSNavPanelExpandedStateForSaveMode2
)

PMPrintingExpandedStateForPrint = %w(
  PMPrintingExpandedStateForPrint
  PMPrintingExpandedStateForPrint2
)

DockAnimationsDuration = %w(
  expose-animation-duration
  autohide-time-modifier
  autohide-delay
  springboard-show-duration
  springboard-hide-duration
  springboard-page-duration
)

MailAnimationsDisable = %w(
  DisableSendAnimations
  DisableReplyAnimations
)

# }}}

Main.run(dryrun: ARGV.include?("--dryrun")) do |c|
  
  hostname = c.ask "What's your hostname"
  c.sysconfig msg: "Setting hostname to `#{hostname}`.",
              name: %w(ComputerName HostName LocalHostName), value: hostname
  c.default msg: "Setting Samba server name to `#{hostname}`.",
            domain: "sysconfig:com.apple.smb.server", name: "NetBIOSName", value: hostname

  c.default msg: "Expanding save panel by default.",
            name: NSNavPanelExpandedStateForSaveMode, value: true
  c.default msg: "Expanding print panel by default.",
            name: PMPrintingExpandedStateForPrint, value: true

  c.default msg: "Automatically quit printer app once the print jobs complete.",
            domain: "com.apple.print.PrintingPrefs", name: "Quit When Finished", value: true

  c.default msg: "Disabling system-wide resume.",
            domain: "com.apple.systempreferences", name: "NSQuitAlwaysKeepsWindows", value: false

  c.default msg: "Disabling the crash reporter.",
            domain: "com.apple.CrashReporter", name: "DialogType", value: "none"

  c.default msg: "Setting Help Viewer windows to non-floating mode.",
            domain: "com.apple.helpviewer", name: "DevMode", value: true

  c.syssetup msg: "Automatically restart if the computer freezes.",
             name: "setrestartfreeze", value: "on"

  c.default msg: "Enabling keyboard repeating.",
            name: "ApplePressAndHoldEnabled", value: false

  c.default msg: "Setting sidebar icon size to medium.",
            name: "NSTableViewDefaultSizeMode", value: 1

  c.default msg: "Always show scrollbars.",
            name: "AppleShowScrollBars", value: "Always"

  c.default msg: "Increase window resize speed.",
            name: "NSWindowResizeTime", value: 0.001
  
  c.default msg: "Unlocking debug menu in Disk Utility.",
            domain: "com.apple.DiskUtility", name: "DUDebugMenuEnabled", value: 1

  c.default msg: "Disabling the warning when changing a file extension.",
            domain: "com.apple.finder", name: "FXEnableExtensionChangeWarning", value: false
            
  #c.default msg: "Disabling Spotlight indexing for any volume that gets mounted and has not yet been indexed before.",
  #          domain: "/.Spotlight-V100/VolumeConfiguration", name: "Exclusions", value: %w(/Volumes)

  c.default msg: "Setting default save target to disk, rather than iCloud.",
            name: "NSDocumentSaveNewDocumentsToCloud", value: false
  
  #c.default msg: "Revealing IP address, hostname, OS version, etc. when clicking the clock in the login window.",
  #          domain: "/Library/Preferences/com.apple.loginwindow", name: "AdminHostInfo", value: "HostName"
end


# vim: set filetype=ruby :
