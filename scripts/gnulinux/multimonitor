#!/usr/bin/env ruby

# {{{ requires

require 'json'
require 'open3'
require 'readline'
require 'mkmf'

# }}}

# {{{ check for external programs

# disable logging, i.e. don't create mkmf.log file
MakeMakefile::Logging.instance_variable_set(:@logfile, File::NULL)
# check if the required external programs are available and executable
%w(xrandr).each do |program|
  error("cannot find the program '#{program}'") unless find_executable0(program)
end

# }}}

# {{{ configuration

# names of the used environment variables
SETUP_NAME_ENVVAR = 'MM_SETUP_NAME'
SETUPS_INFO_ENVVAR = 'MM_SETUPS_INFO'
CONFIG_NAME = 'multimonitor.json'

# the allowed monitor roles
ALLOWED_ROLES = %i(internal external)

# the default setup info; it does nothing particular
DEF_SETUP_INFO = {
  eDP1: { role: :internal }
}

# }}}

# {{{ core class extensions

class String
  # indent the underlying string prepending `prefix` in every line
  def indent(prefix: "\t")
    empty? ? self : prefix + self.split("\n").join("\n#{prefix}")
  end
end

class Hash
  # see {Hash#symbolize}
  def self.symbolize(value, values_to_sym: false)
    if value.is_a?(Hash)
      value.inject({}) do |memo, (k, v)|
        memo[k.to_sym] = Hash.symbolize(v, values_to_sym: values_to_sym)
        memo
      end
    elsif values_to_sym && value.respond_to?(:to_sym)
      value.to_sym
    else
      value
    end
  end

  # transform every symbolizable key (also values if `values_to_sym` is `true`)
  # into a symbol
  def symbolize(values_to_sym: false)
    Hash.symbolize(self, values_to_sym: values_to_sym)
  end
end

# }}}

# {{{ library

# prompt user input with autocompletion
# - `cwords` is an `Array` of completion words
# - `match` is a `Proc`, `:cwords`, or `nil` to indicate the chosen match
#   policy, i.e. when the input should be considered valid and the method should
#   return the matched input
def ask(prompt: 'â†’ ', cwords: [], match: nil)
  res = nil
  if cwords
    cwords.collect!(&:to_s)
    Readline.completion_append_character = ' '
    Readline.completer_word_break_characters = "\n" # pass full string in proc
    Readline.completion_proc = proc do |s|
      if s.empty? || !s.split(' ').find { |elem| cwords.include?(elem) }
        cwords.grep(/^#{Regexp.escape(s)}/)
      else
        []
      end
    end
  end
  loop do
    input = Readline.readline(prompt, true)
    input.strip! unless input.nil?
    case match
    when nil then res = input
    when :cwords then res = input if cwords.include?(input)
    when Proc then res = match.call(input)
    end
    break unless res.nil?
  end
  res
end

# parse the setup informations from all the possible sources
# (config files, env vars) and return them
def parse_setups_info
  setups_info = { default: DEF_SETUP_INFO }
  setups_info.merge!(
    [File.join('/etc', CONFIG_NAME),                # system-wide config file
     File.join(ENV['HOME'], '.config', CONFIG_NAME) # user specific config file
    ].each_with_object({}) do |config, hash|
      begin
        hash.merge!(JSON.parse(File.read(config))) if File.readable?(config)
      rescue JSON::ParserError => err
        warn("skipping invalid configuration at '#{config}': \n" +
             err.message.indent)
      end
    end
  )
  if ENV.has_key?(SETUPS_INFO_ENVVAR)
    begin
      setups_info.merge!(JSON.parse(ENV[SETUPS_INFO_ENVVAR]))
    rescue JSON::ParserError => err
      warn('skipping invalid conifguration in the environment variable ' \
           "'#{SETUPS_INFO_ENVVAR}': \n#{err.message.indent}")
    end
  end
  setups_info.symbolize(values_to_sym: true)
end

# print a warning message in stdout
def warn(msg)
  puts "warning: #{msg}"
end

# print an error message (`msg`) in stdout and exit with failure (`-1`)
def error(msg)
  puts "error: #{msg}"
  exit(-1)
end

# filter `setup_info`, keeping only those having the provided `role`
def monitors_by_role(setup_info, role)
  roles = role.respond_to?(:include?) ? role : [role]
  setup_info.find_all { |_, info| roles.include?(info[:role]) }
end

# run a `xrandr` command passing the provided arguments (`args`)
def xrandr(output, *args, warn: true)
  output = output.to_s
  args.collect!(&:to_s)
  status = nil
  command = ['xrandr', '--output', output, *args]
  Open3.popen3(*command) do |_, stdout, stderr, thr|
    status = thr.value.success?
    out = stdout.readlines
    err = stderr.readlines
    if warn && !status
      msg = "command #{command.join(' ')} failed:"
      msg << "\n\t#{err.join("\t\n")}" unless err.empty?
      warn(msg)
    end
    yield(status, out, err) if block_given?
  end
  return status
end

# perform monitors setup based on the provided informations (`setup_info`)
def perform_setup(setup_info)
  internal_monitor_name, _ = monitors_by_role(setup_info, :internal).first

  monitors_by_role(setup_info, :external)
    .each { |n, _| xrandr(n, '--off') }
  monitors_by_role(setup_info, :external)
    .each { |n, _| xrandr(n, '--auto') }
  monitors_by_role(setup_info, :external)
    .select { |_, i| i[:position] }
    .each { |n, i| xrandr(n, "--#{i[:position]}-of", internal_monitor_name) }
  monitors_by_role(setup_info, :external)
    .select { |_, i| i[:mode] }
    .each { |n, i| xrandr(n, "--mode", i[:mode]) }
end

# entry point
def main(args, env)
  setups_info = parse_setups_info
  # 1. find setup name
  setup_name = (args.first || env[SETUP_NAME_ENVVAR] ||
                ask(cwords: setups_info.keys, match: :cwords)
               ).to_sym
  unless setups_info.include?(setup_name)
    error("invalid setup name: #{setup_name}")
  end
  setup_info = setups_info[setup_name]
  # 2. validate setup info
  unless monitors_by_role(setup_info, ALLOWED_ROLES)
    error('invalid role detected')
  end
  unless monitors_by_role(setup_info, :internal).length == 1
    error('exactly one internal monitor is needed')
  end
  # 3. perform monitors setup
  perform_setup(setup_info)
end

# }}}

main(ARGV, ENV)
